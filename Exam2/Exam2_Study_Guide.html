<!DOCTYPE html>
<html>
<head>
<title>Exam2_Study_Guide.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="exam-2-study-guide---graphs-greedy-and-backtracking">Exam 2 Study Guide - Graphs, Greedy and Backtracking</h1>
<p><strong>Note</strong>: You will be provided with pseudocode from class for these many of these algorithms (karatsuba, dijkstras, heap-shiftdown, n-queens) on the last page of the exam!</p>
<h2 id="graph-fundamentals">Graph Fundamentals</h2>
<h3 id="graph-representation">Graph Representation</h3>
<h4 id="adjacency-list">Adjacency List</h4>
<ul>
<li><strong>Structure</strong>: Array of lists, one per vertex</li>
<li><strong>Space Complexity</strong>: O(V + E)</li>
<li><strong>Edge lookup</strong>: O(degree(v))</li>
<li><strong>Best for</strong>: Sparse graphs (E &lt;&lt; V²)</li>
</ul>
<h4 id="adjacency-matrix">Adjacency Matrix</h4>
<ul>
<li><strong>Structure</strong>: V×V matrix, entry (i,j) = 1 if edge exists</li>
<li><strong>Space Complexity</strong>: O(V²)</li>
<li><strong>Edge lookup</strong>: O(1)</li>
<li><strong>Best for</strong>: Dense graphs, frequent edge lookups</li>
</ul>
<h3 id="graph-types">Graph Types</h3>
<ul>
<li><strong>Undirected</strong>: Edges have no direction (symmetric adjacency matrix)</li>
<li><strong>Directed</strong>: Edges have direction (arrows)</li>
<li><strong>Weighted</strong>: Edges have associated costs/weights</li>
<li><strong>Unweighted</strong>: All edges treated equally (or weight = 1)</li>
</ul>
<h3 id="graph-properties">Graph Properties</h3>
<ul>
<li><strong>Path</strong>: Sequence of vertices connected by edges</li>
<li><strong>Cycle</strong>: Path that starts and ends at same vertex</li>
<li><strong>Connected</strong>: Path exists between any two vertices (undirected)</li>
<li><strong>Strongly Connected</strong>: Path exists in both directions between any two vertices (directed)</li>
<li><strong>Tree</strong>: Connected graph with no cycles (E = V - 1)</li>
</ul>
<h2 id="breadth-first-search-bfs">Breadth-First Search (BFS)</h2>
<h3 id="algorithm-overview">Algorithm Overview</h3>
<p><strong>Purpose</strong>: Explore graph level-by-level from a starting vertex</p>
<p><strong>Key Characteristics</strong>:</p>
<ul>
<li>Uses a <strong>queue</strong> (FIFO)</li>
<li>Visits vertices in order of increasing distance from start</li>
<li>Finds <strong>shortest path</strong> in unweighted graphs</li>
<li>Non-recursive (iterative)</li>
</ul>
<h3 id="bfs-algorithm-steps">BFS Algorithm Steps</h3>
<ol>
<li>Initialize all vertices as unvisited</li>
<li>Mark start vertex as visited, add to queue</li>
<li>While queue not empty:
<ul>
<li>Dequeue vertex v</li>
<li>Process v (record visit order)</li>
<li>For each unvisited neighbor w of v:
<ul>
<li>Mark w as visited</li>
<li>Add w to queue</li>
<li>Set predecessor[w] = v</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="running-time">Running Time</h3>
<ul>
<li><strong>Time Complexity</strong>: O(V + E)
<ul>
<li>Each vertex visited once: O(V)</li>
<li>Each edge examined once: O(E)</li>
</ul>
</li>
<li><strong>Space Complexity</strong>: O(V) for queue and visited array</li>
</ul>
<h3 id="bfs-for-shortest-paths">BFS for Shortest Paths</h3>
<ul>
<li>In <strong>unweighted graphs</strong>, BFS finds shortest path</li>
<li>Distance from start to vertex v = level at which v is discovered</li>
<li>Reconstruct path using predecessor array</li>
</ul>
<h2 id="depth-first-search-dfs">Depth-First Search (DFS)</h2>
<h3 id="algorithm-overview">Algorithm Overview</h3>
<p><strong>Purpose</strong>: Explore graph by going as deep as possible before backtracking</p>
<p><strong>Key Characteristics</strong>:</p>
<ul>
<li>Uses a <strong>stack</strong> (LIFO) - often implemented via recursion</li>
<li>Explores one branch completely before trying another</li>
<li>Useful for cycle detection, topological sorting, strongly connected components</li>
<li>Can be recursive or iterative</li>
</ul>
<h3 id="dfs-algorithm-steps-recursive">DFS Algorithm Steps (Recursive)</h3>
<pre class="hljs"><code><div>DFS(vertex v):
    mark v as visited
    process v (record visit order)
    for each neighbor w of v:
        if w is not visited:
            DFS(w)
</div></code></pre>
<h3 id="dfs-algorithm-steps-iterative">DFS Algorithm Steps (Iterative)</h3>
<ol>
<li>Initialize all vertices as unvisited</li>
<li>Push start vertex onto stack</li>
<li>While stack not empty:
<ul>
<li>Pop vertex v</li>
<li>If v not visited:
<ul>
<li>Mark v as visited</li>
<li>Process v (record visit order)</li>
<li>Push all unvisited neighbors of v onto stack</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="running-time">Running Time</h3>
<ul>
<li><strong>Time Complexity</strong>: O(V + E)
<ul>
<li>Each vertex visited once: O(V)</li>
<li>Each edge examined once (or twice for undirected): O(E)</li>
</ul>
</li>
<li><strong>Space Complexity</strong>: O(V) for recursion stack/explicit stack</li>
</ul>
<h3 id="bfs-vs-dfs-comparison">BFS vs DFS Comparison</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>BFS</th>
<th>DFS</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data Structure</td>
<td>Queue</td>
<td>Stack (or recursion)</td>
</tr>
<tr>
<td>Exploration</td>
<td>Level-by-level</td>
<td>Deep then backtrack</td>
</tr>
<tr>
<td>Shortest Path</td>
<td>Yes (unweighted)</td>
<td>No</td>
</tr>
<tr>
<td>Memory Usage</td>
<td>Higher (stores level)</td>
<td>Lower (path only)</td>
</tr>
<tr>
<td>Use Cases</td>
<td>Shortest path, level-order</td>
<td>Cycle detection, topological sort</td>
</tr>
</tbody>
</table>
<h2 id="dijkstras-algorithm">Dijkstra's Algorithm</h2>
<h3 id="algorithm-overview">Algorithm Overview</h3>
<p><strong>Purpose</strong>: Find shortest paths from start vertex to all other vertices in <strong>weighted graph with non-negative weights</strong></p>
<p><strong>Key Characteristics</strong>:</p>
<ul>
<li><strong>Greedy algorithm</strong> - always picks closest unvisited vertex</li>
<li>Uses <strong>priority queue (min-heap)</strong> to select next vertex</li>
<li>Maintains <strong>key values</strong> (current shortest distance) for each vertex</li>
<li>Maintains <strong>predecessor</strong> array to reconstruct paths</li>
<li><strong>Does not work with negative edge weights</strong></li>
</ul>
<h3 id="dijkstras-algorithm-steps">Dijkstra's Algorithm Steps</h3>
<ol>
<li>
<p><strong>Initialize</strong>:</p>
<ul>
<li>Set key[start] = 0, all other keys = ∞</li>
<li>Set all predecessors to null</li>
<li>Add all vertices to min-heap (priority queue)</li>
</ul>
</li>
<li>
<p><strong>Main Loop</strong> (while heap not empty):</p>
<ul>
<li>Extract vertex u with minimum key value</li>
<li>For each neighbor v of u:
<ul>
<li>Calculate new_distance = key[u] + weight(u, v)</li>
<li>If new_distance &lt; key[v]:
<ul>
<li>Update key[v] = new_distance</li>
<li>Update predecessor[v] = u</li>
<li>Decrease key of v in heap</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Result</strong>:</p>
<ul>
<li>key[v] = shortest distance from start to v</li>
<li>Reconstruct path by following predecessors backwards</li>
</ul>
</li>
</ol>
<h3 id="running-time">Running Time</h3>
<ul>
<li>
<p><strong>Time Complexity</strong>: O((V + E) log V) with binary heap</p>
<ul>
<li>Extract-min: O(log V) × V times = O(V log V)</li>
<li>Decrease-key: O(log V) × at most E times = O(E log V)</li>
<li>Total: O((V + E) log V)</li>
</ul>
</li>
</ul>
<h3 id="key-insights">Key Insights</h3>
<ul>
<li><strong>Greedy Property</strong>: Once a vertex is removed from heap, its shortest path is finalized</li>
<li><strong>Optimal Substructure</strong>: All sub-paths of a shortest path are also shortest paths</li>
</ul>
<h3 id="dijkstras-algorithm-design-technique">Dijkstra's Algorithm Design Technique</h3>
<p><strong>Greedy Algorithm</strong>:</p>
<ul>
<li>Makes locally optimal choice at each step</li>
<li>Selects vertex with minimum key value</li>
<li>Never reconsiders once a vertex is processed</li>
<li>Greedy choice: &quot;Visit closest unvisited vertex next&quot;</li>
</ul>
<h2 id="greedy-algorithms">Greedy Algorithms</h2>
<h3 id="greedy-algorithm-characteristics">Greedy Algorithm Characteristics</h3>
<p><strong>Core Principle</strong>: Make the locally optimal choice at each step, hoping to find a global optimum</p>
<p><strong>Key Properties</strong>:</p>
<ul>
<li><strong>Greedy Choice Property</strong>: A global optimum can be reached by making locally optimal choices</li>
<li><strong>Optimal Substructure</strong>: An optimal solution contains optimal solutions to subproblems</li>
<li><strong>Never backtracks</strong>: Once a choice is made, it's never reconsidered</li>
<li><strong>Efficiency</strong>: Often runs in polynomial time</li>
</ul>
<p><strong>Proving Correctness</strong>:</p>
<ol>
<li><strong>Greedy Choice Property</strong>: Show that making the greedy choice leaves a subproblem of the same form</li>
<li><strong>Optimal Substructure</strong>: Prove that combining the greedy choice with an optimal solution to the subproblem yields an optimal solution to the original problem</li>
</ol>
<h3 id="interval-scheduling-problem">Interval Scheduling Problem</h3>
<p><strong>Problem</strong>: Given n intervals with start and finish times, select the maximum number of non-overlapping intervals.</p>
<p><strong>Input</strong>: Set of intervals {(s₁, f₁), (s₂, f₂), ..., (sₙ, fₙ)} where sᵢ = start time, fᵢ = finish time</p>
<p><strong>Goal</strong>: Find maximum-size subset of mutually compatible (non-overlapping) intervals</p>
<p><strong>Greedy Strategy</strong>: Always select the interval with the <strong>earliest finish time</strong> among remaining compatible intervals</p>
<p><strong>Algorithm</strong>:</p>
<ol>
<li>Sort intervals by finish time (f₁ ≤ f₂ ≤ ... ≤ fₙ)</li>
<li>Initialize result set S = {interval 1}</li>
<li>For each interval i from 2 to n:
<ul>
<li>If interval i is compatible with all intervals in S (sᵢ ≥ finish time of last interval in S):
<ul>
<li>Add interval i to S</li>
</ul>
</li>
</ul>
</li>
<li>Return S</li>
</ol>
<p><strong>Running Time</strong>: O(n log n) for sorting + O(n) for selection = <strong>O(n log n)</strong></p>
<p><strong>Why This Works</strong>:</p>
<ul>
<li>Selecting earliest finish time leaves maximum room for future intervals</li>
<li>Greedy choice is always part of some optimal solution</li>
<li>Can prove by exchange argument: any optimal solution can be transformed to include the greedy choice</li>
</ul>
<h3 id="minimum-cost-to-connect-sticks">Minimum Cost to Connect Sticks</h3>
<p><strong>Problem</strong>: Given n sticks of various lengths, connect them all into one stick. Cost to connect two sticks = sum of their lengths. Find minimum total cost.</p>
<p><strong>Input</strong>: Array of stick lengths [s₁, s₂, ..., sₙ]</p>
<p><strong>Goal</strong>: Minimize total cost of connecting all sticks</p>
<p><strong>Greedy Strategy</strong>: Always connect the two <strong>shortest sticks</strong> available</p>
<p><strong>Algorithm</strong>:</p>
<ol>
<li>Create a min-heap from all stick lengths</li>
<li>Initialize total_cost = 0</li>
<li>While heap has more than one stick:
<ul>
<li>Extract two smallest sticks: stick1 and stick2</li>
<li>cost = stick1 + stick2</li>
<li>Add cost to total_cost</li>
<li>Insert combined stick (length = cost) back into heap</li>
</ul>
</li>
<li>Return total_cost</li>
</ol>
<p><strong>Running Time</strong>:</p>
<ul>
<li>Build heap: O(n)</li>
<li>n-1 iterations, each with 2 extract-min + 1 insert: O(n log n)</li>
<li><strong>Total: O(n log n)</strong></li>
</ul>
<p><strong>Example</strong>:</p>
<pre class="hljs"><code><div>Sticks: [2, 4, 3]

Step 1: Connect 2 and 3 → cost = 5, sticks = [5, 4], total = 5
Step 2: Connect 5 and 4 → cost = 9, sticks = [9], total = 14

Total cost: 14
</div></code></pre>
<p><strong>Why This Works</strong>:</p>
<ul>
<li>Sticks connected earlier are counted multiple times in total cost</li>
<li>Minimizing early connections (by using shortest sticks) minimizes total cost</li>
<li>Similar to Huffman coding tree construction</li>
<li>Can prove optimal by induction on number of sticks</li>
</ul>
<h2 id="backtracking-algorithms">Backtracking Algorithms</h2>
<h3 id="n-queens-problem">N-Queens Problem</h3>
<p><strong>Problem</strong>: Place n queens on an n×n chessboard such that no two queens attack each other.</p>
<p><strong>Constraints</strong>: Queens can attack any piece in the same:</p>
<ul>
<li>Row</li>
<li>Column</li>
<li>Diagonal (both directions)</li>
</ul>
<p><strong>Goal</strong>: Find a valid placement of all n queens (or determine if one exists in a given subtree)</p>
<p><strong>Backtracking Strategy</strong>:</p>
<ul>
<li>Place queens one column at a time</li>
<li>For each column, try each row position</li>
<li>If a position is safe, place queen and recurse to next column</li>
<li>If no safe position exists in current column, backtrack to previous column</li>
<li>Prune branches early when a placement violates constraints</li>
</ul>
<p><strong>Note</strong>: Exam questions will specify whether to use 0-based or 1-based indexing. Examples below use 1-based indexing.</p>
<h3 id="n-queens-algorithm-steps">N-Queens Algorithm Steps</h3>
<pre class="hljs"><code><div>NQueens(col, board):
    if col &gt; n:
        return true  // All queens placed successfully

    for row from 1 to n:
        if isSafe(row, col, board):
            board[col] = row  // Place queen
            if NQueens(col + 1, board):
                return true
            // Backtrack: remove queen (implicit when trying next row)

    return false  // No valid placement found

isSafe(row, col, board):
    for prevCol from 1 to col-1:
        prevRow = board[prevCol]
        // Check same row
        if prevRow == row:
            return false
        // Check diagonals
        if abs(prevRow - row) == abs(prevCol - col):
            return false
    return true
</div></code></pre>
<h3 id="tracing-n-queens-search-tree">Tracing N-Queens Search Tree</h3>
<p><strong>Key Concepts for Exam</strong>:</p>
<ol>
<li>
<p><strong>Board Representation</strong>: Array where board[i] = j means &quot;queen in column i is at row j&quot;</p>
</li>
<li>
<p><strong>Search Tree Structure</strong>:</p>
<ul>
<li>Each level represents a column (1 through n)</li>
<li>Each branch represents a row choice (1 through n)</li>
<li>Leaves represent complete or failed placements</li>
</ul>
</li>
<li>
<p><strong>Determining Valid Solutions in Subtree</strong>:</p>
<ul>
<li>Start from given partial board state</li>
<li>Check if current state is valid (no conflicts)</li>
<li>If invalid, subtree has NO solutions</li>
<li>If valid, trace remaining columns systematically</li>
</ul>
</li>
</ol>
<p><strong>Example Trace for 4-Queens</strong> (1-indexed):</p>
<pre class="hljs"><code><div>Col 1: Try rows 1, 2, 3, 4
  |
  ├─ Q at (row=1, col=1)
  |    Col 2: Try rows 1, 2, 3, 4
  |    |
  |    ├─ row=1? NO - same row as (1,1)
  |    ├─ row=2? NO - diagonal with (1,1): |1-2| = |1-2| = 1
  |    ├─ row=3? YES - safe: row ≠ 1, |1-3| = 2 ≠ |1-2| = 1
  |    |    Col 3: Try rows 1, 2, 3, 4
  |    |    |
  |    |    ├─ row=1? NO - same row as (1,1)
  |    |    ├─ row=2? YES - safe: rows ≠ 1,3 and diagonals OK
  |    |    |    Col 4: Try rows 1, 2, 3, 4
  |    |    |    |
  |    |    |    ├─ row=1? NO - same row as (1,1)
  |    |    |    ├─ row=2? NO - same row as (2,3)
  |    |    |    ├─ row=3? NO - same row as (3,2)
  |    |    |    └─ row=4? NO - diagonal with (1,1): |1-4| = |1-4| = 3
  |    |    |    └─ BACKTRACK - no valid row in col 4
  |    |    |
  |    |    ├─ row=3? NO - same row as (3,2)
  |    |    └─ row=4? NO - diagonal with (3,2): |3-4| = |2-3| = 1
  |    |    └─ BACKTRACK - no more rows to try in col 3
  |    |
  |    └─ row=4? YES - safe: row ≠ 1, |1-4| = 3 ≠ |1-2| = 1
  |         Col 3: Try rows 1, 2, 3, 4
  |         |
  |         ├─ row=1? NO - same row as (1,1)
  |         ├─ row=2? YES - safe: rows ≠ 1,4 and diagonals OK
  |         |    Col 4: Try rows 1, 2, 3, 4
  |         |    |
  |         |    ├─ row=1? NO - same row as (1,1)
  |         |    ├─ row=2? NO - same row as (2,3)
  |         |    ├─ row=3? YES - safe: rows ≠ 1,4,2 and no diagonal conflicts
  |         |    |    SUCCESS! Solution found: [1,4,2,3]
  |         |    └─ (no need to try row=4)
  |         ...
  |
  ├─ Q at (row=2, col=1)
  |    Col 2: Try rows 1, 2, 3, 4
  |    |
  |    ├─ row=1? NO - diagonal with (2,1): |2-1| = |1-2| = 1
  |    ├─ row=2? NO - same row as (2,1)
  |    ├─ row=3? NO - diagonal with (2,1): |2-3| = |1-2| = 1
  |    └─ row=4? YES - safe: row ≠ 2, |2-4| = 2 ≠ |1-2| = 1
  |         Col 3: Try rows 1, 2, 3, 4
  |         |
  |         ├─ row=1? YES - safe: rows ≠ 2,4 and diagonals OK
  |         |    Col 4: Try rows 1, 2, 3, 4
  |         |    |
  |         |    ├─ row=1? NO - same row as (1,3)
  |         |    ├─ row=2? NO - same row as (2,1)
  |         |    ├─ row=3? YES - safe!
  |         |    |    SUCCESS! Solution found: [2,4,1,3]
  |         |    └─ (no need to try row=4)
  ...
</div></code></pre>
<h3 id="checking-for-valid-solutions-in-a-subtree">Checking for Valid Solutions in a Subtree</h3>
<p><strong>Step-by-Step Process</strong>:</p>
<ol>
<li>
<p><strong>Verify Current State</strong>:</p>
<ul>
<li>Check all placed queens for conflicts</li>
<li>If conflict exists, answer is NO</li>
</ul>
</li>
<li>
<p><strong>Identify Remaining Columns</strong>:</p>
<ul>
<li>Count how many columns still need queens</li>
<li>These form the subtree to explore</li>
</ul>
</li>
<li>
<p><strong>For Each Remaining Column</strong>:</p>
<ul>
<li>Try each row systematically (1 through n)</li>
<li>Check if position is safe against ALL previously placed queens</li>
<li>If safe, recursively check next column</li>
<li>If unsafe, skip this branch (pruning)</li>
</ul>
</li>
<li>
<p><strong>Termination Conditions</strong>:</p>
<ul>
<li><strong>Success</strong>: All columns filled with no conflicts</li>
<li><strong>Failure</strong>: Current column has no safe rows (backtrack)</li>
</ul>
</li>
</ol>
<p><strong>Example Problem</strong> (1-indexed): Given board state [2, 4, ?, ?] for 4-Queens (columns 1-2 filled, columns 3-4 empty), does subtree contain valid solution?</p>
<pre class="hljs"><code><div>Current state (board = [2, 4, ?, ?]):
. . ? ?   (row 1)
Q . ? ?   (row 2, col 1)
. . ? ?   (row 3)
. Q ? ?   (row 4, col 2)

Col 3 options:
- Row 1: Safe? Check against (2,1) and (4,2)
  - Not same row as 2 or 4 ✓
  - Diagonal from (2,1)? |2-1| == |1-3|? 1 ≠ 2 ✓
  - Diagonal from (4,2)? |4-1| == |2-3|? 3 ≠ 1 ✗ NO - diagonal conflict

- Row 2: Safe? Check against (2,1) and (4,2)
  - Same row as (2,1)? YES ✗ NO - row conflict

- Row 3: Safe? Check against (2,1) and (4,2)
  - Not same row as 2 or 4 ✓
  - Diagonal from (2,1)? |2-3| == |1-3|? 1 ≠ 2 ✓
  - Diagonal from (4,2)? |4-3| == |2-3|? 1 == 1 ✗ NO - diagonal conflict

- Row 4: Safe? Check against (2,1) and (4,2)
  - Same row as (4,2)? YES ✗ NO - row conflict

Answer: NO valid solution exists in this subtree (all rows in col 3 have conflicts)
</div></code></pre>
<p><strong>Alternative Example with Valid Solution</strong>: board = [3, 1, ?, ?]</p>
<p>If we instead had board = [3, 1, ?, ?]:</p>
<pre class="hljs"><code><div>Col 3 options:
- Row 4: Safe? Check against (3,1) and (1,2)
  - Not same row ✓
  - Diagonal from (3,1)? |3-4| == |1-3|? 1 ≠ 2 ✓
  - Diagonal from (1,2)? |1-4| == |2-3|? 3 ≠ 1 ✗ NO - diagonal conflict

- Eventually trying all positions leads to board = [3,1,4,2] ✓ VALID SOLUTION
</div></code></pre>
<h3 id="running-time">Running Time</h3>
<ul>
<li><strong>Worst Case</strong>: O(n!) - must explore all permutations</li>
<li><strong>Recurrence</strong>: T(n) = n·T(n-1) + O(n)
<ul>
<li>At each level, try up to n positions</li>
<li>Each position requires O(n) safety check</li>
<li>Recurse to next column (n-1 columns remaining)</li>
</ul>
</li>
<li><strong>With Pruning</strong>: Much better in practice, but still exponential</li>
</ul>
<h3 id="key-insights">Key Insights</h3>
<ul>
<li><strong>Backtracking</strong> explores search space systematically</li>
<li><strong>Pruning</strong> eliminates invalid branches early</li>
<li><strong>Constraint checking</strong> prevents exploring doomed subtrees</li>
<li>Position early in tree affects search tree size dramatically</li>
</ul>
<h2 id="algorithm-design-techniques-summary">Algorithm Design Techniques Summary</h2>
<table>
<thead>
<tr>
<th>Technique</th>
<th>Strategy</th>
<th>Key Characteristics</th>
<th>Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Divide-and-Conquer</strong></td>
<td>Break into subproblems, solve recursively, combine</td>
<td>Independent subproblems; T(n) = aT(n/b) + f(n)</td>
<td>Merge Sort, Binary Search, Karatsuba</td>
</tr>
<tr>
<td><strong>Greedy</strong></td>
<td>Make locally optimal choice at each step</td>
<td>Never backtracks; must prove correctness; efficient</td>
<td>Dijkstra's, Interval Scheduling, Connect Sticks</td>
</tr>
<tr>
<td><strong>Backtracking</strong></td>
<td>Build incrementally, backtrack when invalid</td>
<td>Explores search tree; abandons bad paths early</td>
<td>N-Queens, Sudoku, Graph Coloring</td>
</tr>
</tbody>
</table>
<h2 id="heap-data-structure">Heap Data Structure</h2>
<h3 id="heap-properties">Heap Properties</h3>
<p><strong>Min-Heap Property</strong>:</p>
<ul>
<li>Parent is smaller than or equal to children</li>
<li>Smallest element at root (index 0 or 1)</li>
</ul>
<p><strong>Max-Heap Property</strong>:</p>
<ul>
<li>Parent is greater than or equal to children</li>
<li>Largest element at root</li>
</ul>
<h3 id="heap-violations">Heap Violations</h3>
<p><strong>Checking Min-Heap Property</strong>:</p>
<ul>
<li>For each node with index i (up to heapSize-1):
<ul>
<li>Check if key[i] ≤ key[left_child(i)] (if left child exists)</li>
<li>Check if key[i] ≤ key[right_child(i)] (if right child exists)</li>
</ul>
</li>
<li><strong>Violation</strong>: Parent is larger than one or more children</li>
</ul>
<p><strong>Important</strong>: Only check nodes within heapSize</p>
<ul>
<li>Elements beyond heapSize are not part of the heap</li>
</ul>
<h3 id="heap-operations">Heap Operations</h3>
<p><strong>Insert</strong>: O(log n)</p>
<ul>
<li>Add element at end</li>
<li>Bubble up to restore heap property</li>
</ul>
<p><strong>Extract-Min/Max</strong>: O(log n)</p>
<ul>
<li>Remove root</li>
<li>Move last element to root</li>
<li>Bubble down to restore heap property</li>
</ul>
<p><strong>Decrease-Key</strong>: O(log n)</p>
<ul>
<li>Reduce key value of element</li>
<li>Bubble up to restore heap property</li>
</ul>
<p><strong>Build-Heap</strong>: O(n)</p>
<ul>
<li>Convert unordered array to heap</li>
<li>Heapify from bottom up</li>
</ul>
<h2 id="quick-reference-formulas">Quick Reference Formulas</h2>
<h3 id="graph-algorithms">Graph Algorithms</h3>
<ul>
<li><strong>BFS/DFS Time</strong>: O(V + E)</li>
<li><strong>Dijkstra Time</strong>: O((V + E) log V) with binary heap</li>
<li><strong>BFS Space</strong>: O(V) for queue</li>
<li><strong>DFS Space</strong>: O(V) for stack/recursion</li>
</ul>
<h3 id="karatsuba">Karatsuba</h3>
<ul>
<li><strong>Standard Multiplication</strong>: Θ(n²)</li>
<li><strong>Karatsuba</strong>: Θ(n^log₂(3)) ≈ Θ(n^1.585)</li>
<li><strong>Recurrence</strong>: T(n) = 3T(n/2) + Θ(n)</li>
</ul>
<h3 id="n-queens">N-Queens</h3>
<ul>
<li><strong>Running Time</strong>: O(n!)</li>
<li><strong>Recurrence</strong>: T(n) = n·T(n-1) + O(n)</li>
</ul>
<h3 id="heap-indexing-0-based">Heap Indexing (0-based)</h3>
<ul>
<li><strong>Parent</strong>: ⌊(i-1)/2⌋</li>
<li><strong>Left Child</strong>: 2i + 1</li>
<li><strong>Right Child</strong>: 2i + 2</li>
</ul>
<h3 id="heap-indexing-1-based">Heap Indexing (1-based)</h3>
<ul>
<li><strong>Parent</strong>: ⌊i/2⌋</li>
<li><strong>Left Child</strong>: 2i</li>
<li><strong>Right Child</strong>: 2i + 1</li>
</ul>
<hr>
<p><em>Course content developed by Declan Gray-Mullen for WNEU with Claude</em></p>

</body>
</html>
